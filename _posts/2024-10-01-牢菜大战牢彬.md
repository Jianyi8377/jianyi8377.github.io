---
layout: post
title:  "牢菜大战牢彬 - C语言飞机大战项目解析"
date:   2024-10-01 17:02:45 +0800
categories: Jekyll 入门
tags: C语言 EasyX 游戏开发 飞机大战
---

# 牢菜大战牢彬
> 以此项目缅怀两位故人——牢菜和牢彬，用C语言复刻童年经典，让友谊藏在每一行代码里。

这是我用 C语言 + EasyX 图形库独立完成的第一个游戏项目，没有照搬模板，从图形渲染、碰撞检测到音效播放，全程自主开发。既是对C语言结构体、函数封装、指针等基础的巩固，也是一份特殊的纪念。

---

## 🌟 项目背景与纪念意义
之所以选择用 C语言做飞机大战，是因为我突然想起了牢菜和老彬两个喜欢扫二维码的故人。

作为编程新手，开发过程中踩了很多坑：从不知道如何处理图形渲染，到解决画面闪烁、敌机随机生成异常；从不会写碰撞检测，到实现音效和计分系统。每一个功能的实现，都是一次成长，也让这个项目更有意义——它不仅是一个游戏，更是我们友谊的见证。

---

## 🛠️ 技术栈与环境配置
### 1. 核心技术
<table style="width:100%;border-collapse:collapse;border:1px solid #eee;">
  <tr style="background:#f5f5f5;">
    <th style="padding:12px;text-align:left;border-bottom:1px solid #eee;">技术类别</th>
    <th style="padding:12px;text-align:left;border-bottom:1px solid #eee;">具体工具/库</th>
    <th style="padding:12px;text-align:left;border-bottom:1px solid #eee;">作用说明</th>
  </tr>
  <tr>
    <td style="padding:12px;border-bottom:1px solid #eee;">编程语言</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">C语言（标准C99）</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">核心开发语言，高效、贴近底层</td>
  </tr>
  <tr>
    <td style="padding:12px;border-bottom:1px solid #eee;">图形库</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">EasyX 2023（graphics.h）</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">处理窗口创建、图形渲染、贴图</td>
  </tr>
  <tr>
    <td style="padding:12px;border-bottom:1px solid #eee;">音效支持</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">Windows API（mmsystem.h）</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">播放背景音乐、射击/爆炸音效</td>
  </tr>
  <tr>
    <td style="padding:12px;border-bottom:1px solid #eee;">开发工具</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">VS2022</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">代码编辑、编译运行（兼容EasyX）</td>
  </tr>
  <tr>
    <td style="padding:12px;">资源处理</td>
    <td style="padding:12px;">图片（JPG/PNG）、音效（MP3/WAV）</td>
    <td style="padding:12px;">游戏背景、角色、音效资源</td>
  </tr>
</table>

### 2. 环境搭建步骤（可直接复制执行）
#### （1）安装 EasyX 图形库
1. 下载 EasyX 安装包：[EasyX 官网](https://easyx.cn/)（选择对应编译器版本，如 Dev-C++/VS2022）
2. 双击安装，选择你的编译器路径，完成集成（无需手动配置头文件和库）

#### （2）配置资源文件
项目目录结构必须如下（否则图片/音效无法加载）：
```
laocai-vs-laobin/
├── main.c（核心源码文件）
├── image/（图片文件夹，必须同名）
│   ├── bk.jpg（背景图）
│   ├── cd1.png（玩家飞机图）
│   ├── fm1.png（子弹图）
│   ├── dj1.png（大敌机图）
│   └── dj2.png（小敌机图）
└── sound/（音效文件夹，必须同名）
    ├── bk.mp3（背景音乐）
    ├── man.wav（射击音效）
    ├── say.wav（击中音效）
    └── out.wav（敌机爆炸音效）
```

#### （3）编译运行
1. 用VS2022 打开项目
2. 直接编译并运行，无需额外配置编译选项

> 提示：若运行报错「找不到图片/音效」，检查资源文件夹路径是否正确（必须和代码中 `".\\image\\"` `".\\sound\\"` 对应）；若音效无法播放，确保安装了 `winmm.lib` 库（VS 已默认集成）。

---

## 🎮 核心功能与源码解析
### 1. 项目整体架构
整个项目采用「模块化封装」设计，核心分为 5 大模块，结构清晰：
```c
// 核心模块划分
1. 资源加载模块（loadImg()）：加载图片、音效资源
2. 初始化模块（gameInit()/enemyHP()）：初始化玩家、子弹、敌机的属性
3. 渲染模块（gameDraw()）：绘制背景、角色、子弹、敌机（双缓冲防闪烁）
4. 逻辑模块（playerMove()/enemyMove()/playPlane()）：移动、碰撞检测、计分
5. 音效模块（Music()/Music1()-Music3()）：背景音乐和音效播放
```

### 2. 关键结构体设计（数据封装）
用结构体统一管理角色属性，让代码更易维护：
```c
// 飞机（玩家/子弹/敌机）的通用结构体
struct Plane
{
    int x;          // 横坐标（左上角为原点）
    int y;          // 纵坐标
    bool live;      // 是否存活（true=存活，false=死亡）
    int width;      // 宽度（贴图尺寸）
    int height;     // 高度（贴图尺寸）
    int hp;         // 血量（敌机区分大小：大敌机3血，小敌机1血）
    int type;       // 类型（BIG=大敌机，SMALL=小敌机）
}player, bull[BULL_NUM], enemy[ENEMY_NUM];
```

### 3. 核心功能源码解析
#### （1）双缓冲渲染（解决画面闪烁）
```c
// main函数中启用双缓冲，这是EasyX图形库防闪烁的关键
BeginBatchDraw();  // 开始双缓冲
while (1)
{
    gameDraw();     // 绘制所有元素（先画到缓冲区）
    FlushBatchDraw();// 一次性刷新到屏幕（避免逐元素绘制的闪烁）
    // 其他逻辑（移动、碰撞检测）
}
```

#### （2）玩家控制（WASD/方向键移动 + 空格射击）
```c
void playerMove(int speed)
{
    // 非阻塞键盘监听（流畅不卡顿）
    if (GetAsyncKeyState(VK_UP) || GetAsyncKeyState('W'))  // 上移
        if (player.y > 0) player.y -= speed;
    if (GetAsyncKeyState(VK_DOWN) || GetAsyncKeyState('S'))// 下移
        if (player.y < HEIGHT) player.y += speed;
    if (GetAsyncKeyState(VK_LEFT) || GetAsyncKeyState('A'))// 左移
        if (player.x > 0) player.x -= speed;
    if (GetAsyncKeyState(VK_RIGHT) || GetAsyncKeyState('D'))// 右移
        if (player.x < WIDTH) player.x += speed;
    
    // 空格射击（500ms冷却，避免子弹连发过快）
    static DWORD t1 = 0, t2 = 0;
    if (GetAsyncKeyState(VK_SPACE) && t2 - t1 > 500)
    {
        Music1();     // 播放射击音效
        creatBullte();// 创建子弹
        t1 = t2;
    }
    t2 = GetTickCount();
}
```

#### （3）碰撞检测（精准判断子弹击中敌机）
采用「轴对齐边界框（AABB）」算法，判断子弹和敌机的矩形区域是否重叠：
```c
void playPlane()
{
    for (int i = 0; i < ENEMY_NUM; i++)  // 遍历所有敌机
    {
        if (!enemy[i].live) continue;    // 跳过已死亡的敌机
        for (int k = 0; k < BULL_NUM; k++)// 遍历所有子弹
        {
            if (bull[k].live)  // 只判断存活的子弹
            {
                // 计算子弹和敌机的边界框
                int bulletLeft = bull[k].x;
                int bulletRight = bull[k].x + 50;
                int bulletTop = bull[k].y;
                int bulletBottom = bull[k].y + 50;
                
                int enemyLeft = enemy[i].x;
                int enemyRight = enemy[i].x + enemy[i].width;
                int enemyTop = enemy[i].y;
                int enemyBottom = enemy[i].y + enemy[i].height;
                
                // 边界框重叠 = 击中
                if (bulletRight > enemyLeft && bulletLeft < enemyRight 
                    && bulletBottom > enemyTop && bulletTop < enemyBottom)
                {
                    bull[k].live = false;  // 子弹消失
                    enemy[i].hp--;         // 敌机掉血
                    Music2();              // 击中音效
                    if (enemy[i].hp <= 0)  // 敌机血量为0 = 消灭
                    {
                        enemy[i].live = false;
                        score++;            // 计分+1
                        Music3();           // 爆炸音效
                    }
                }
            }
        }
    }
}
```

#### （4）敌机随机生成与移动
```c
// 随机生成大/小敌机（30%概率大敌机，70%概率小敌机）
void enemyHP(int i)
{
    int s = rand() % 8 + 0;
    if (s <= 3)  // 大敌机（3血、尺寸114x114）
    {
        enemy[i].type = BIG;
        enemy[i].hp = 3;
        enemy[i].width = 114;
        enemy[i].height = 114;
    }
    else  // 小敌机（1血、尺寸52x52）
    {
        enemy[i].type = SMALL;
        enemy[i].hp = 1;
        enemy[i].width = 52;
        enemy[i].height = 52;
    }
}

// 500ms生成一架敌机（避免生成过密）
void Time()
{
    static DWORD t1, t2;
    if (t2 - t1 > 500)
    {
        createEnemy();  // 生成敌机
        t1 = t2;
    }
    t2 = clock();
}

// 敌机向下移动，出界后标记为死亡
void enemyMove(int speed)
{
    for (int i = 0; i < ENEMY_NUM; i++)
    {
        if (enemy[i].live)
        {
            enemy[i].y += speed;
            if (enemy[i].y > HEIGHT)  // 超出屏幕下边界
                enemy[i].live = false;
        }
    }
}
```

#### （5）音效系统（背景音乐+触发音效）
```c
// 背景音乐（循环播放MP3）
void Music()
{
    mciSendString("open .\\sound\\bk.mp3 alias bgm", NULL, 0, NULL);
    mciSendString("play bgm", NULL, 0, NULL);
    mciSendString("setaudio bgm volume to 500", NULL, 0, NULL); // 音量0-1000
}

// 射击音效（WAV格式，异步播放不阻塞游戏）
void Music1()
{
    PlaySound(".\\sound\\man.wav", NULL, SND_FILENAME | SND_ASYNC);
}

// 击中音效
void Music2()
{
    PlaySound(".\\sound\\say.wav", NULL, SND_FILENAME | SND_ASYNC);
}

// 敌机爆炸音效
void Music3()
{
    PlaySound(".\\sound\\out.wav", NULL, SND_FILENAME | SND_ASYNC);
}
```

---

## 📸 游戏效果展示
### 1. 游戏界面
<img src="/images/牢菜大战牢彬/1.jpg" alt="游戏主界面" style="max-width:100%;height:auto;border-radius:8px;margin:16px 0;">
> 说明：背景为自定义图片，手持大炮的是牢菜，其他突击的是「牢彬军团」，子弹是牢菜最爱的蜂蜜。（由于关乎对方隐私已进行鬼图打码）

### 2. 核心玩法
- 操控：WASD 或方向键控制飞机移动，空格发射子弹
- 规则：消灭敌机得1分，大敌机需击中3次，小敌机1次即可消灭
- 音效：背景音乐为牢大的小曲，射击音效为man，击中音效为whatcanisay，爆炸音效为manbaout。
- 视觉：双缓冲渲染，画面流畅无闪烁。

### 3. 运行截图
<img src="/images/牢菜大战牢彬/2.jpg" alt="战斗画面" style="max-width:100%;height:auto;border-radius:8px;margin:16px 0;">
> 说明：左下角实时显示当前得分，敌机随机生成，难度适中，适合休闲闯关。

---

## 🚩 开发过程与问题解决
<table style="width:100%;border-collapse:collapse;border:1px solid #eee;">
  <tr style="background:#f5f5f5;">
    <th style="padding:12px;text-align:left;border-bottom:1px solid #eee;">问题描述</th>
    <th style="padding:12px;text-align:left;border-bottom:1px solid #eee;">解决方案</th>
    <th style="padding:12px;text-align:left;border-bottom:1px solid #eee;">收获与思考</th>
  </tr>
  <tr>
    <td style="padding:12px;border-bottom:1px solid #eee;">画面闪烁严重</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">启用 EasyX 双缓冲（BeginBatchDraw()/FlushBatchDraw()）</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">理解图形渲染原理：逐元素绘制会导致闪烁，双缓冲可一次性刷新</td>
  </tr>
  <tr>
    <td style="padding:12px;border-bottom:1px solid #eee;">敌机生成位置重复</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">将 srand(time(NULL)) 放在 main 函数开头（仅初始化1次随机种子）</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">掌握随机数生成逻辑：多次初始化种子会导致随机性降低</td>
  </tr>
  <tr>
    <td style="padding:12px;border-bottom:1px solid #eee;">子弹连发过快</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">用 GetTickCount() 设置 500ms 冷却时间</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">学会用计时器控制事件触发频率，优化游戏体验</td>
  </tr>
  <tr>
    <td style="padding:12px;border-bottom:1px solid #eee;">碰撞检测不准确</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">采用边界框（AABB）算法，精确计算子弹和敌机的坐标范围</td>
    <td style="padding:12px;border-bottom:1px solid #eee;">理解碰撞检测的核心思想：矩形区域重叠即判定为碰撞</td>
  </tr>
  